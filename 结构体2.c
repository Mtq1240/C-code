//结构体传参
#include<stdio.h>
struct S
{
	int data[1000];
	int num;
};

struct S s = { {1,2,3,4,5},1000 };
//结构体传参
void print1(struct S s)
{
	printf("%d\n", s.num);
}
//结构体地址传参
void print2(struct S* ps)
{
	printf("%d\n", ps->num);
}
int main()
{
	print1(s);//传结构体
	print2(&s);//传地址
	return 0;
}
//print2函数在传参的时候,参数是需要压栈,会有时间和空间上的系统开销
//如果传递一个结构体对象的时候,结构体过大,参数压栈的系统开销比较大,所以会导致性能的下降
//结论:结构体传参的时候,要传结构体的地址

//位段:在一定程度上节省空间
//位段的声明和结构是类似的,有两个不同:
//1.位段的成员必须是:int,unsigned或signed int
//2.位段的成员名后面有一个冒号和一个数字

//位段的内存分配:
//1.位段的成员可以是int int signed int或者是char(属于整型家族)类型
//2.位段的空间上是按照需要以4个字节(int)或者1个字节(char)的方式来开辟的
//3.位段涉及很多不确定因素,位段是不跨平台的,注重可移植的程序应该避免使用位段
struct S
{
	char a : 3;
	char b : 4;
	char c : 5;
	char d : 6;
};


//位段的跨平台问题:
//1.int位段被当成有符号数还是无符号数是不确定的
//2.位段中最大位的数目不能确定(16位机器最大16,32机器最大32)
//3.位段中的成员在内存中从左向右分配,还是从右向左标准未定义
//4.当一个结构包含两个位段,第二个位段成员比较大,无法容纳第一个位段剩余的位时,是舍弃位重新开辟还是利用,也是不确定的

//结论:位段可以很好的节省空间,但是又跨平台的问题



//枚举
//1.增加代码的可读性和可维护性
//2.和#define定义的标识符比较枚举有类型检查,更加严谨
//3.防止命名污染
//4.便于调试
//5,使用方便,一次可以定义多个常量
enum Color
{
	red,
	green,
	blue
};
